- Class: meta
  Course: STEP0042
  Lesson: Flipped Coding 1 - foundations for vectors, logical and subsetting
  Author: Michael Veale & Ine Steenmans
  Type: Standard
  Organization: UCL STEaPP (includes GNU content from https://github.com/swirldev/swirl_courses. Distributed GNU GPL v3)
  Version: 2

- Class: text
  Output: Hi everyone! Welcome to the first flipped coding activity for our analysis module. Good work installing this package. We're going to be primarily learning R *within R*, which is pretty cool. Once you've completed it, you'll need to take a screenshot and paste in the Moodle forum. Whenever you're ready, just hit ENTER to continue.
  
- Class: cmd_question
  Output: In its simplest form, R can be used as an interactive calculator. Type
    5 + 7 in the *Console* and press Enter.
  CorrectAnswer: 5 + 7
  AnswerTests: omnitest(correctExpr='5 + 7')
  Hint: Type 5 + 7 and press Enter.
  
- Class: text
  Output: R simply prints the result of 12 by default. However, R is a programming
    language and often the reason we use a programming language as opposed to a calculator
    is to automate some process or avoid unnecessary repetition.
    
- Class: text
  Output: In this case, we may want to use our result from above in a second calculation.
    Instead of retyping 5 + 7 every time we need it, we can just create a new variable
    that stores the result.

- Class: text
  Output: 'The way you assign a value to a variable in R is by using the assignment
    operator, which is just a ''less than'' symbol followed by a ''minus'' sign. It
    looks like this: <-'
    
- Class: text
  Output: Think of the assignment operator as an arrow. You are assigning the value
    on the right side of the arrow to the variable name on the left side of the arrow.

- Class: cmd_question
  Output: To assign the result of 5 + 7 to a new variable called x, you type x <-
    5 + 7. This can be read as 'x is 5 plus 7'. Give it a try now.
  CorrectAnswer: x <- 5 + 7
  AnswerTests: any_of_exprs('x <- 5 + 7', 'x <- 7 + 5')
  Hint: Type x <- 5 + 7. It's important to include a single space on each side of
    the assignment operator, but do NOT put a space between the `<` and the `-` that
    form the arrow.
    
- Class: text
  Output: You'll notice that R did not print the result of 12 this time. When you
    use the assignment operator, R assumes that you don't want to see the result immediately,
    but rather that you intend to use the result for something else later on.

- Class: cmd_question
  Output: To view the contents of the variable x, just type x and press Enter. Try
    it now.
  CorrectAnswer: x
  AnswerTests: omnitest(correctExpr='x')
  Hint: Type x and press Enter. This will automatically print the value of x.

- Class: cmd_question
  Output: Now, store the result of x - 3 in a new variable called y.
  CorrectAnswer: y <- x - 3
  AnswerTests: omnitest(correctExpr='y <- x - 3')
  Hint: Type y <- x - 3 and press Enter. Whether you use x - 3 or x-3 is personal
    preference, but it's good habit to include a space on either side of the assignment
    operator.
    
- Class: cmd_question
  Output: What is the value of y? Type y to find out.
  CorrectAnswer: 'y'
  AnswerTests: omnitest(correctExpr='y')
  Hint: Type y and press Enter.

- Class: text
  Output: The real power in R is to manipulate lots of numbers at once. So let's create a small collection of numbers called a vector. Any object
    that contains data such as numbers is called a data structure and numeric vectors are the simplest
    type of data structure in R. In fact, technically, even a single number is considered a vector
    of length one — so you've already made a couple in assigning x and y.
    
- Class: cmd_question
  Output: The easiest way to create a vector is with the c() function, which stands
    for 'concatenate' or 'combine'. To create a vector containing the numbers 1.1,
    9, and 3.14, type c(1.1, 9, 3.14). Try it now and store the result in a variable
    called z.
  CorrectAnswer: z <- c(1.1, 9, 3.14)
  AnswerTests: omnitest(correctExpr='z <- c(1.1, 9, 3.14)')
  Hint: Inputting z <- c(1.1, 9, 3.14) will assign the vector (1.1, 9, 3.14) to a
    new variable called z. Including single spaces after the commas in the vector
    is not required, but helps make your code less cluttered and more readable.

- Class: cmd_question
  Output: Anytime you have questions about a particular function, you can access R's
    built-in help files via the `?` command. For example, if you want more information
    on the c() function, type ?c without the parentheses that normally follow a function
    name. Give it a try.
  CorrectAnswer: ?c
  AnswerTests: omnitest(correctExpr='?c')
  Hint: Type ?c and press Enter. This will bring up the help file for the c() function.

- Class: cmd_question
  Output: You can combine vectors to make a new vector. Create a new vector that contains
    z, 555, then z again in that order. Don't assign this vector to a new variable,
    so that we can just see the result immediately.
  CorrectAnswer: c(z, 555, z)
  AnswerTests: omnitest(correctExpr='c(z, 555, z)')
  Hint: Type c(z, 555, z). Don't create a new variable. We just want to view the result.

- Class: cmd_question
  Output: 'Numeric vectors can be used in arithmetic expressions. Type the following
    to see what happens: z * 2 + 100.'
  CorrectAnswer: z * 2 + 100
  AnswerTests: omnitest(correctExpr='z * 2 + 100')
  Hint: Enter z * 2 + 100, without assigning the result to a variable. The `*` symbol
    is used for multiplication and shares a key with the number 8 on many keyboards.

- Class: text
  Output: First, R multiplied each of the three elements in z by 2. Then it added
    100 to each element to get the result you see above.

- Class: text
  Output: Other common arithmetic operators are `+`, `-`, `/`, and `^` (where x^2
    means 'x squared'). To take the square root, use the sqrt() function and to take
    the absolute value, use the abs() function.

- Class: cmd_question
  Output: Take the square root of z - 1 and assign it to a new variable called my_sqrt.
  CorrectAnswer: my_sqrt <- sqrt(z - 1)
  AnswerTests: omnitest(correctExpr='my_sqrt <- sqrt(z - 1)')
  Hint: Assign the result of sqrt(z - 1) to a variable called my_sqrt.

- Class: mult_question
  Output: Before we view the contents of the my_sqrt variable, what do you think it
    contains?
  CorrectAnswer: a vector of length 3
  AnswerChoices: a vector of length 3; a single number (i.e a vector of length 1);
    a vector of length 0 (i.e. an empty vector)
  AnswerTests: omnitest(correctVal='a vector of length 3')
  Hint: 'Think about how R handled the other ''vectorised'' operations: element-by-element.'

- Class: cmd_question
  Output: Print the contents of my_sqrt.
  CorrectAnswer: my_sqrt
  AnswerTests: omnitest(correctExpr='my_sqrt')
  Hint: Just type my_sqrt and press Enter to view its value.

- Class: text
  Output: As you may have guessed, R first subtracted 1 from each element of z, then
    took the square root of each element. This leaves you with a vector of the same
    length as the original vector z.

- Class: cmd_question
  Output: Now, create a new variable called my_div that gets the value of z divided
    by my_sqrt.
  CorrectAnswer: my_div <- z / my_sqrt
  AnswerTests: omnitest(correctExpr='my_div <- z / my_sqrt')
  Hint: Enter my_div <- z / my_sqrt. The spaces on either side of the `/` sign are not
    required, but can often improve readability by making code appear less cluttered.
    In the end, it's personal preference.

- Class: mult_question
  Output: Which statement do you think is true?
  CorrectAnswer: The first element of my_div is equal to the first element of z divided
    by the first element of my_sqrt, and so on...
  AnswerChoices: The first element of my_div is equal to the first element of z divided
    by the first element of my_sqrt, and so on...; my_div is a single number (i.e a
    vector of length 1); my_div is undefined
  AnswerTests: omnitest(correctVal='The first element of my_div is equal to the first
    element of z divided by the first element of my_sqrt, and so on...')
  Hint: Think about how R handled the other 'vectorised' operations like `+` and `*`.

- Class: cmd_question
  Output: Go ahead and print the contents of my_div.
  CorrectAnswer: my_div
  AnswerTests: omnitest(correctExpr='my_div')
  Hint: Type my_div and press Enter to see its contents.

- Class: text
  Output: When given two vectors of the same length, R simply performs the specified
    arithmetic operation (`+`, `-`, `*`, etc.) element-by-element. If the vectors
    are of different lengths, R 'recycles' the shorter vector until it is the same
    length as the longer vector.

- Class: text
  Output: When we did z * 2 + 100 in our earlier example, z was a vector of length
    3, but technically 2 and 100 are each vectors of length 1.

- Class: text
  Output: 'Behind the scenes, R is ''recycling'' the 2 to make a vector of 2s and
    the 100 to make a vector of 100s. In other words, when you ask R to compute z
    * 2 + 100, what it really computes is this: z * c(2, 2, 2) + c(100, 100, 100).'

- Class: cmd_question
  Output: To see another example of how this vector 'recycling' works, try adding
    c(1, 2, 3, 4) and c(0, 10). Don't worry about saving the result in a new variable.
  CorrectAnswer: c(1, 2, 3, 4) + c(0, 10)
  AnswerTests: omnitest(correctExpr='c(1, 2, 3, 4) + c(0, 10)')
  Hint: Enter c(1, 2, 3, 4) + c(0, 10) in the console to see how R adds two vectors
    of different length. Don't assign the result to a variable.

- Class: text
  Output: If the length of the shorter vector does not divide evenly into the length
    of the longer vector, R will still apply the 'recycling' method, but will throw
    a warning to let you know something fishy might be going on.

- Class: cmd_question
  Output: Try c(1, 2, 3, 4) + c(0, 10, 100) for an example.
  CorrectAnswer: c(1, 2, 3, 4) + c(0, 10, 100)
  AnswerTests: omnitest(correctExpr='c(1, 2, 3, 4) + c(0, 10, 100)')
  Hint: Type c(1, 2, 3, 4) + c(0, 10, 100) to see how R handles adding two vectors,
    when the shorter vector's length does not divide evenly into the longer vector's
    length. Don't worry about assigning the result to a variable.

- Class: text
  Output: Tip: You can type skip() to move on, play() to experiment (then nxt() to return), main() for the menu, and bye() to save and exit.
    
- Class: text
  Output: Lets quickly look at a couple of time-saving tricks.

- Class: text
  Output: Earlier in the lesson, you computed z * 2 + 100. Let's pretend that you made a mistake and that you meant to add 1000 instead of 100. You could either re-type the expression, or...

- Class: cmd_question
  Output: In many programming environments, the up arrow will cycle through previous commands. Try hitting the up arrow on your keyboard until you get to this command (z * 2 + 100), then change 100 to 1000 and hit Enter. If the up arrow doesn't work for you, just type the corrected command.
  CorrectAnswer: z * 2 + 1000
  AnswerTests: omnitest(correctExpr='z * 2 + 1000')
  Hint: If your environment does not support the up arrow feature, then just type the corrected command to move on.

- Class: text
  Output: Now let's pretend you'd like to view the contents of a variable that you created earlier, but you can't seem to remember if you named it my_div or myDiv. You could try both and see what works, or...

- Class: cmd_question
  Output: You can type the first two letters of the variable name, then hit the Tab key (possibly more than once). Most programming environments will provide a list of variables that you've created that begin with 'my'. This is called auto-completion and can be quite handy when you have many variables in your workspace. Give it a try. (If auto-completion doesn't work for you, just type my_div and press Enter.)
  CorrectAnswer: my_div
  AnswerTests: omnitest(correctExpr='my_div')
  Hint: If your programming environment doesn't support auto-completion, just type my_div and hit Enter to move on.

- Class: text
  Output: So, c() is an easy way to create a vector, but it's not the only way. Sometimes we'll want to import data, which we will look at more closely later. But other times, we want to make sequences of numbers.

- Class: cmd_question
  Output: The simplest way to create a sequence of numbers in R is by using the `:`
    operator. Type 1:20 to see how it works.
  CorrectAnswer: '1:20'
  AnswerTests: omnitest(correctExpr='1:20')
  Hint: Type 1:20 with no spaces. Make sure to use a regular colon and NOT a semi-colon.
  
- Class: cmd_question
  Output: 'What happens if we do 15:1? Give it a try to find out.'
  CorrectAnswer: '15:1'
  AnswerTests: omnitest(correctExpr='15:1')
  Hint: Type 15:1 and press Enter.

- Class: cmd_question
  Output: It counted backwards in increments of 1 as you can see. 
    What both of these are doing is making a vector. Try to store the vector of 1:15 in
    a new variable, a.
  CorrectAnswer: a <- 1:15
  AnswerTests: omnitest(correctExpr='a <- 1:15')
  Hint: Make sure you use the <- operator, with 1:15 on the right hand side, and a on the left hand side.
  
- Class: text
  Output: Often, we don't want to count in ones, but want more control than what
    the `:` operator gives us. The seq() function serves this purpose.

- Class: text
  Output: In R, functions (almost) always look like a word, followed by brackets. You mustn't put a space between the word and the brackets, and you must be careful with capital letters, as R is *case-sensitive*. Sometimes, functions (or variable names) contain underscores (_) or numbers, but they do not include spaces.

- Class: cmd_question
  Output: The most basic use of the seq() function does exactly the same thing as the `:` operator.
    Try seq(1, 20) to see this.
  CorrectAnswer: seq(1, 20)
  AnswerTests: omnitest(correctExpr='seq(1, 20)')
  Hint: Type seq(1, 20) and press Enter. The space after the comma is not required,
    but is recommended as it tends to make your code appear less cluttered.
    
- Class: cmd_question
  Output: This gives us the same output as 1:20. However, let's say that instead we
    want a vector of numbers ranging from 0 to 10, incremented by 0.5. seq(0, 10,
    by=0.5) does just that. Try it out.
  CorrectAnswer: seq(0, 10, by=0.5)
  AnswerTests: omnitest(correctExpr='seq(0, 10, by=0.5)')
  Hint: You are still using the seq() function here, but this time with an extra argument
    that tells R you want to increment your sequence by 0.5. Try seq(0, 10, by=0.5).

- Class: cmd_question
  Output: Or maybe we don't care what the increment is and we just want a sequence
    of 30 numbers between 5 and 10. seq(5, 10, length=30) does the trick. Give it
    a shot now and store the result in a new variable called my_seq.
  CorrectAnswer: my_seq <- seq(5, 10, length=30)
  AnswerTests: omnitest(correctExpr='my_seq <- seq(5, 10, length=30)')
  Hint: 'You''re using the same function here, but changing its arguments for different
    results. Be sure to store the result in a new variable called my_seq, like this:
    my_seq <- seq(5, 10, length=30).'

- Class: cmd_question
  Output: To confirm that my_seq has length 30, we can use the length() function.
    Try it now.
  CorrectAnswer: length(my_seq)
  AnswerTests: omnitest(correctExpr='length(my_seq)')
  Hint: Use length(my_seq) to view the length of the my_seq variable.

- Class: text
  Output: Let's pretend we don't know the length of my_seq, but we want to generate
    a sequence of integers from 1 to N, where N represents the length of the my_seq
    vector. In other words, we want a new vector (1, 2, 3, ...) that is the same length
    as my_seq.

- Class: cmd_question
  Output: 'There are several ways we could do this. One possibility is to combine
    the `:` operator and the length() function like this: 1:length(my_seq). Give that
    a try.'
  CorrectAnswer: 1:length(my_seq)
  AnswerTests: omnitest(correctExpr='1:length(my_seq)')
  Hint: Try 1:length(my_seq), without assigning the result to a new variable.
  
- Class: text
  Output: One more function related to creating sequences of numbers is rep(), which
    stands for 'replicate'. Let's look at a few uses.

- Class: cmd_question
  Output: If we're interested in creating a vector that contains 40 zeros, we can
    use rep(0, times = 40). Try it out.
  CorrectAnswer: rep(0, times = 40)
  AnswerTests: omnitest(correctExpr='rep(0, times = 40)')
  Hint: Type rep(0, times = 40) to make a vector containing 40 zeros.

- Class: cmd_question
  Output: If instead we want our vector to contain 10 repetitions of the vector (0,
    1, 2), we can do rep(c(0, 1, 2), times = 10). Go ahead.
  CorrectAnswer: rep(c(0, 1, 2), times = 10)
  AnswerTests: omnitest(correctExpr='rep(c(0, 1, 2), times = 10)')
  Hint: Try rep(c(0, 1, 2), times = 10) for a different variation on the same theme.
    Be sure to use the c() function to tell R that the numbers 0, 1, and 2 make up
    a vector.

- Class: cmd_question
  Output: Let's say that rather than repeating the vector (0, 1, 2) over
    and over again, we want our vector to contain 10 zeros, then 10 ones, then 10
    twos. We can do this with the `each` argument. Try rep(c(0, 1, 2), each = 10).
  CorrectAnswer: rep(c(0, 1, 2), each = 10)
  AnswerTests: omnitest(correctExpr='rep(c(0, 1, 2), each = 10)')
  Hint: Type rep(c(0, 1, 2), each = 10) to see how the `each` argument to the rep()
    function alters its behavior slightly.

- Class: text
  Output: Vectors are the building blocks in R. And they're not just restricted to numbers. So far, we've been learning about numeric vectors, but there are two other types of vectors which are crucial to working with R. These are text vectors and logical vectors.
  
- Class: text
  Output: Let's start with *logical* vectors. What do we mean by this? Well, the word logical refers to TRUE and to FALSE. In computing, whether something is true or false is really important. So in R, these words are protected words, and it means we can type them and they get special recognition.
  
- Class: text
  Output: We all know that 1 + 1 is 2. R does too. So lets ask it. To ask the question "is something equals to something", we use two equals signs in a row.
  
- Class: cmd_question
  Output: Ask R if 1 + 1 is 2.
  CorrectAnswer: 1 + 1 == 2
  AnswerTests: any_of_exprs('1 + 1 == 2', '2 == 1 + 1')
  Hint: Don't type 1 + 1 = 2, but try 1 + 1 == 2.

- Class: text
  Output: So that was TRUE. What about false? Try the same thing to see if it equals 3.
  
- Class: cmd_question
  Output: Ask R if 1 + 1 is 3.
  CorrectAnswer: 1 + 1 == 3
  AnswerTests: any_of_exprs('1 + 1 == 3', '3 == 1 + 1')
  Hint: Don't type 1 + 1 = 3, but try 1 + 1 == 3.

- Class: text
  Output: Hardly rocket science, but that was FALSE. These are important building blocks though. In R, we use TRUE and FALSE instead of Yes or No when storing data about yes/no answers. 
  
- Class: text
  Output: Logical vectors can contain the values TRUE, FALSE, and NA (for 'not available').
    These values are generated as the result of logical 'conditions'. Let's experiment
    with some simple conditions.

- Class: cmd_question
  Output: First, create a numeric vector num_vect that contains the values 0.5, 55,
    -10, and 6.
  CorrectAnswer: num_vect <- c(0.5, 55, -10, 6)
  AnswerTests: omnitest(correctExpr='num_vect <- c(0.5, 55, -10, 6)')
  Hint: Recall that the c() function is used for creating a vector. If you forget
    how to use it, use ?c to access the help file. Don't forget to assign the result
    to a new variable called num_vect.

- Class: cmd_question
  Output: Now, create a variable called tf that gets the result of num_vect < 1, which
    is read as 'num_vect is less than 1'.
  CorrectAnswer: tf <- num_vect < 1
  AnswerTests: omnitest(correctExpr='tf <- num_vect < 1')
  Hint: Use tf <- num_vect < 1 to assign the result of num_vect < 1 to a variable
    called tf.

- Class: mult_question
  Output: What do you think tf will look like?
  CorrectAnswer: a vector of 4 logical values
  AnswerChoices: a vector of 4 logical values; a single logical value
  AnswerTests: omnitest(correctVal='a vector of 4 logical values')
  Hint: Remember the vector arithmetic? The theme was that R performs many
    operations on an element-by-element basis. We called these 'vectorised' operations.

- Class: cmd_question
  Output: Print the contents of tf now.
  CorrectAnswer: tf
  AnswerTests: omnitest(correctExpr='tf')
  Hint: Just type tf and press Enter to view the its value.

- Class: text
  Output: The statement num_vect < 1 is a condition and tf tells us whether each corresponding
    element of our numeric vector num_vect satisfies this condition.

- Class: text
  Output: The first element of num_vect is 0.5, which is less than 1 and therefore
    the statement 0.5 < 1 is TRUE. The second element of num_vect is 55, which is
    greater than 1, so the statement 55 < 1 is FALSE. The same logic applies for the
    third and fourth elements.

- Class: cmd_question
  Output: Let's try another. Type num_vect >= 6 without assigning the result to a
    new variable.
  CorrectAnswer: num_vect >= 6
  AnswerTests: omnitest(correctExpr='num_vect >= 6')
  Hint: Don't create a new variable on this one. We just want to see the result of
    num_vect >= 6. Make sure there is no space between the `>` and `=` symbols. Think
    of them as one symbol representing 'greater than or equal to'.

- Class: text
  Output: This time, we are asking whether each individual element of num_vect is
    greater than OR equal to 6. Since only 55 and 6 are greater than or equal to 6,
    the second and fourth elements of the result are TRUE and the first and third elements
    are FALSE.

- Class: text
  Output: The `<` and `>=` symbols in these examples are called 'logical operators'.
    Other logical operators include `>`, `<=`, `==` (which we have seen) for exact equality, and `!=` for
    inequality.

- Class: text
  Output: If we have two logical expressions, A and B, we can ask whether at least
    one is TRUE with A | B (logical 'or' a.k.a. 'union') or whether they are both
    TRUE with A & B (logical 'and' a.k.a. 'intersection'). Lastly, !A is the negation
    of A and is TRUE when A is FALSE and vice versa.

- Class: text
  Output: It's a good idea to spend some time playing around with various combinations
    of these logical operators until you get comfortable with their use. They're really powerful 
    and if you spend time with them they can save you so much time! We'll do
    a few examples here to get you started.

- Class: text
  Output: Try your best to predict the result of each of the following statements.
    You can use pencil and paper to work them out if it's helpful. If you get stuck,
    just guess and you've got a 50% chance of getting the right answer!

- Class: mult_question
  Output: (3 > 5) & (4 == 4)
  CorrectAnswer: 'FALSE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='FALSE')
  Hint: Break this problem down into 2 pieces. The `&` in the middle states that BOTH
    pieces are TRUE. Your job is to figure out if that is an accurate statement. If
    so, the entire condition is TRUE. If not, it's FALSE.

- Class: mult_question
  Output: (TRUE == TRUE) | (TRUE == FALSE)
  CorrectAnswer: 'TRUE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='TRUE')
  Hint: Break this problem down into 2 pieces. The `|` in the middle states that AT
    LEAST ONE of the pieces is TRUE. Your job is to figure out if that is an accurate
    statement. If so, the entire condition is TRUE. If not, it's FALSE.

- Class: mult_question
  Output: ((111 >= 111) | !(TRUE)) & ((4 + 1) == 5)
  CorrectAnswer: 'TRUE'
  AnswerChoices: TRUE; FALSE
  AnswerTests: omnitest(correctVal='TRUE')
  Hint: This is a tricky one. Remember that the `!` symbol negates whatever comes
    after it. There's also an 'order of operations' going on here. Conditions that
    are enclosed within parentheses should be evaluated first. Then, work your way
    outwards.

- Class: text
  Output: Don't worry if you found these to be tricky. They're supposed to be. Working
    with logical statements in R takes practice, but your efforts will be rewarded as it will make things easier in the long run!

- Class: text
  Output: So, that's us having done logical vectors. Now let's talk about character vectors. In R when we say character, we really mean text. Each part of a vector, instead of being a number, or TRUE or FALSE, is a "string" of text. You can tell this because R will wrap it in quotation marks.
  
- Class: text
  Output: Character vectors are very common in R. Double quotes are used to distinguish
    character objects, as in the following example.

- Class: cmd_question
  Output: 'Create a character vector that contains the following words: "My", "name",
    "is". Remember to enclose each word in its own set of double quotes, so that
    R knows they are character strings. Store the vector in a variable called my_char.'
  CorrectAnswer: my_char <- c("My", "name", "is")
  AnswerTests: omnitest(correctExpr='my_char <- c("My", "name", "is")')
  Hint: Type my_char <- c("My", "name", "is") to create a new variable called my_char
    that contains a character vector of length 3. Make sure that the commas separating
    the words are OUTSIDE of the double quotes, or else R thinks the commas are part
    of the words.

- Class: cmd_question
  Output: Print the contents of my_char to see what it looks like.
  CorrectAnswer: my_char
  AnswerTests: omnitest(correctExpr='my_char')
  Hint: Type my_char to view its contents.

- Class: text
  Output: Right now, my_char is a character vector of length 3. Let's say we want
    to join the elements of my_char together into one continuous character string
    (i.e. a character vector of length 1). We can do this using the paste() function.

- Class: text
  Output: In Session 3 you built a tiny “age converter” and a summary sentence with paste(). You’ll see the same ideas here (numbers + text).
  
- Class: cmd_question
  Output: Type paste(my_char, collapse = " ") now. Make sure there's a space between
    the double quotes in the `collapse` argument. You'll see why in a second.
  CorrectAnswer: paste(my_char, collapse = " ")
  AnswerTests: omnitest(correctExpr='paste(my_char, collapse = " ")')
  Hint: Use paste(my_char, collapse = " ") to collapse the words in the vector so
    they almost form a sentence. There should be a single space between the double
    quotes in the `collapse` argument so that there are single spaces separating the
    words.

- Class: text
  Output: The `collapse` argument to the paste() function tells R that when we join
    together the elements of the my_char character vector, we'd like to separate them
    with single spaces.

- Class: text
  Output: It seems that we're missing something.... Ah, yes! Your name!

- Class: cmd_question
  Output: 'To add (or ''concatenate'') your name to the end of my_char, use the c()
    function like this: c(my_char, "your_name_here"). Place your name in double quotes
    where I''ve put "your_name_here". Try it now, storing the result in a new variable
    called my_name.'
  CorrectAnswer: my_name <- c(my_char, "Michael")
  AnswerTests: var_is_a("character", "my_name"); expr_uses_func("c"); expr_creates_var("my_name");
    val_has_length(4)
  Hint: Tack your name on to the end of the my_char vector using the c() function.  Be
    sure to assign the result to a new variable called my_name. If your name was "Swirl",
    you would type my_name <- c(my_char, "Swirl").

- Class: cmd_question
  Output: Take a look at the contents of my_name.
  CorrectAnswer: my_name
  AnswerTests: omnitest(correctExpr='my_name')
  Hint: Type my_name and press Enter to view its contents.

- Class: cmd_question
  Output: Now, use the paste() function once more to join the words in my_name together
    into a single character string. Don't forget to say collapse = " "!
  CorrectAnswer: paste(my_name, collapse = " ")
  AnswerTests: omnitest(correctExpr='paste(my_name, collapse = " ")')
  Hint: Use paste(my_name, collapse = " ") to join all four words together, separated
    by single spaces.

- Class: text
  Output: In this example, we used the paste() function to collapse the elements of
    a single character vector. paste() can also be used to join the elements of multiple
    character vectors.

- Class: cmd_question
  Output: In the simplest case, we can join two character vectors that are each of
    length 1 (i.e. join two words). Try paste("Hello", "world!", sep = " "), where
    the `sep` argument tells R that we want to separate the joined elements with a
    single space.
  CorrectAnswer: paste("Hello", "world!", sep = " ")
  AnswerTests: omnitest(correctExpr='paste("Hello", "world!", sep = " ")')
  Hint: Enter paste("Hello", "world!", sep = " ") to join the two words "Hello" and
    "world", separated by a single space. There should be a single space between the
    double quotes in the `sep` argument to the paste() function.

- Class: cmd_question
  Output: For a slightly more complicated example, we can join two vectors, each of
    length 3. Use paste() to join the integer vector 1:3 with the character vector c("X", "Y", "Z"). This time, use sep
    = "" to leave no space between the joined elements.
  CorrectAnswer: paste(1:3, c("X", "Y", "Z"), sep = "")
  AnswerTests: any_of_exprs('paste(1:3, c("X", "Y", "Z"), sep = "")', 'paste(c(1:3), c("X", "Y", "Z"), sep = "")')
  Hint: Use paste(1:3, c("X", "Y", "Z"), sep = "") to see what happens when we join
    two vectors of equal length using paste().

- Class: text
  Output: What do you think will happen if our vectors are of different length?

- Class: cmd_question
  Output: Vector recycling! Try paste(LETTERS, 1:4, sep = "-"). LETTERS is a
    predefined variable in R containing a character vector of all 26 letters in the
    English alphabet.
  CorrectAnswer: paste(LETTERS, 1:4, sep = "-")
  AnswerTests: omnitest(correctExpr='paste(LETTERS, 1:4, sep = "-")')
  Hint: Type paste(LETTERS, 1:4, sep = "-") to see how R recycles the vector 1:4 to  match
    the length of LETTERS. Notice we are using `-` as our separator this time instead
    of a single space.

- Class: text
  Output: Since the character vector LETTERS is longer than the numeric vector 1:4,
    R simply recycles, or repeats, 1:4 until it matches the length of LETTERS.

- Class: text
  Output: Also worth noting is that the numeric vector 1:4 gets 'coerced' into a character
    vector by the paste() function.

- Class: text
  Output: Coercion means is that the
    numbers 1, 2, 3, and 4 in the output above are no longer numbers to R, but rather
    characters "1", "2", "3", and "4".

- Class: text
  Output: Vectors can only be one type, such as character, numeric, or logical - they cannot be two types at once. To go betweeen the types manually, we can use the 'as' functions. These include as.logical(), as.character() and as.numeric(). Without using these functions, R will guess what the best kind of format for the vector you have chosen is.

- Class: text
  Output: Everything can be turned into a character vector - it just gets quotation marks around each element. But not everything can be turned into a numeric vector, for example. Only number, in numeric form, can! If R gets asked to turn a word into a number, it will turn it into a NA instead, which is a special value that stands for "not available". We call these "missing values".
  
- Class: mult_question
  Output: What would the result be if you tried to turn the character vector c("1", "2", "three", "4") into a numeric vector by wrapping it in as.numeric()?
  AnswerChoices: c(1, 2, 3, 4);c("one", "two", "three", "four");c(one, two, three, four);c(1, 2, NA, 4)
  CorrectAnswer: c(1, 2, NA, 4)
  AnswerTests: omnitest(correctVal= 'c(1, 2, NA, 4)')
  Hint: Remember, only numeric numbers can be coerced into a numeric vector.

- Class: text
  Output: Dealing with NAs (missing values) in R can seem frustrating, as for messy data (which much data is!) you can get NAs a lot. But there's a reason for this. R is much stricter about values than, say, Excel, because it stops errors in your analysis. If there's an NA being thrown up in your code, you know there's something fishy going on, and should find it and understand it in order to make sure it's not contaminating your results!

- Class: text
  Output: Okay, so we've seen how to use numbers, logical statements, and characters in vectors. What we haven't done yet is to see how we can choose and find different values within a vector. This is a really important skill within R!

- Class: cmd_question
  Output: I'd like you to create a vector called x that contains a random ordering of 20 numbers (from a standard normal distribution) and 20 NAs. The command is x <- sample(c(rnorm(20), rep(NA, 20))). 
  CorrectAnswer: x <- sample(c(rnorm(20), rep(NA, 20)))
  AnswerTests: omnitest('x <- sample(c(rnorm(20), rep(NA, 20)))')
  Hint: Make sure you aren't adding a space between the < and the -, and make sure you count the brackets! The command is x <- sample(c(rnorm(20), rep(NA, 20))). 

- Class: cmd_question
  Output: Super. Type x now to see what it looks like.
  CorrectAnswer: x
  AnswerTests: omnitest(correctExpr='x')
  Hint: Type x to view its contents.

- Class: text
  Output: The way you tell R that you want to select some particular elements (i.e. a 'subset') from a vector is by placing an 'index vector' in square brackets immediately following the name of the vector.

- Class: cmd_question
  Output: For a simple example, try x[1:10] to view the first ten elements of x.
  CorrectAnswer: x[1:10]
  AnswerTests: omnitest(correctExpr='x[1:10]')
  Hint: View the first ten elements of x with x[1:10].

- Class: text
  Output: Index vectors come in four different flavors -- logical vectors, vectors of positive integers, vectors of negative integers, and vectors of character strings -- each of which we'll cover in this lesson.

- Class: text
  Output: Let's start by indexing with logical vectors. One common scenario when working with real-world data is that we want to extract all elements of a vector that are not NA (i.e. missing data). Recall that is.na(x) yields a vector of logical values the same length as x, with TRUEs corresponding to NA values in x and FALSEs corresponding to non-NA values in x.

- Class: mult_question
  Output: What do you think x[is.na(x)] will give you?
  AnswerChoices: A vector of all NAs; A vector with no NAs; A vector of TRUEs and FALSEs; A vector of length 0
  CorrectAnswer: A vector of all NAs
  AnswerTests: omnitest(correctVal="A vector of all NAs")
  Hint: Remember that is.na(x) tells us where the NAs are in a vector. So if we subset x based on that, what do you expect to happen?

- Class: cmd_question
  Output: Prove it to yourself by typing x[is.na(x)].
  CorrectAnswer: x[is.na(x)]
  AnswerTests: omnitest(correctExpr='x[is.na(x)]')
  Hint: Type x[is.na(x)] to see that you get all NAs, which is clearly not what we want!

- Class: cmd_question
  Output: Recall that `!` gives us the negation of a logical expression, so !is.na(x) can be read as 'is not NA'. Therefore, if we want to create a vector called y that contains all of the non-NA values from x, we can use y <- x[!is.na(x)]. Give it a try.
  CorrectAnswer: y <- x[!is.na(x)]
  AnswerTests: omnitest(correctExpr='y <- x[!is.na(x)]')
  Hint: Type y <- x[!is.na(x)] to capture all non-missing values from x.

- Class: cmd_question
  Output: Print y to the console.
  CorrectAnswer: 'y'
  AnswerTests: omnitest(correctExpr='y')
  Hint: Type y to view its contents.

- Class: text
  Output: Now that we've isolated the non-missing values of x and put them in y, we can subset y as we please.

- Class: mult_question
  Output: Recall that the expression y > 0 will give us a vector of logical values the same length as y, with TRUEs corresponding to values of y that are greater than zero and FALSEs corresponding to values of y that are less than or equal to zero. What do you think y[y > 0] will give you?
  AnswerChoices: A vector of all the positive elements of y; A vector of all the negative elements of y; A vector of all NAs; A vector of length 0; A vector of TRUEs and FALSEs
  CorrectAnswer: A vector of all the positive elements of y
  AnswerTests: omnitest(correctVal="A vector of all the positive elements of y")
  Hint: The logical expression y > 0 will give us TRUE for each element of y that is positive. Based on that, what do you think y[y > 0] will return?

- Class: cmd_question
  Output: Type y[y > 0] to see that we get all of the positive elements of y, which are also the positive elements of our original vector x.
  CorrectAnswer: y[y > 0]
  AnswerTests: omnitest(correctExpr='y[y > 0]')
  Hint: Type y[y > 0] to view only the positive elements of y.

- Class: cmd_question
  Output: You might wonder why we didn't just start with x[x > 0] to isolate the positive elements of x. Try that now to see why.
  CorrectAnswer: x[x > 0]
  AnswerTests: omnitest(correctExpr='x[x > 0]')
  Hint: Try x[x > 0] to see why we didn't use this approach.

- Class: text
  Output: Since NA is not a value, but rather a placeholder for an unknown quantity, the expression NA > 0 evaluates to NA. Hence we get a bunch of NAs mixed in with our positive numbers when we do this.

- Class: cmd_question
  Output: Combining our knowledge of logical operators with our new knowledge of subsetting, we could do this -- x[!is.na(x) & x > 0]. is.na() is a useful function that does what it says on the tin - returns TRUE if something is NA, and FALSE if it isn't. Adding an exclamation mark, if you remember turns it (effectively) into "isn't na?". Try it out.
  CorrectAnswer: x[!is.na(x) & x > 0]
  AnswerTests: omnitest(correctExpr='x[!is.na(x) & x > 0]')
  Hint: Try x[!is.na(x) & x > 0] to see what you get.

- Class: text
  Output: In this case, we request only values of x that are both non-missing AND greater than zero.

- Class: text
  Output: I've already shown you how to subset just the first ten values of x using x[1:10]. In this case, we're providing a vector of positive integers inside of the square brackets, which tells R to return only the elements of x numbered 1 through 10.

- Class: text
  Output: Many programming languages use what's called 'zero-based indexing', which means that the first element of a vector is considered element 0. R uses 'one-based indexing', which (you guessed it!) means the first element of a vector is considered element 1.

- Class: cmd_question
  Output: Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x? Hint -- Use the c() function to specify the element numbers as a numeric vector.
  CorrectAnswer: x[c(3, 5, 7)]
  AnswerTests: omnitest(correctExpr='x[c(3, 5, 7)]')
  Hint: Create a vector of indexes with c(3, 5, 7), then put that inside of the square brackets.

- Class: text
  Output: What if we're interested in all elements of x EXCEPT the 2nd and 10th? It would be pretty tedious to construct a vector containing all numbers 1 through 40 EXCEPT 2 and 10.

- Class: cmd_question
  Output: Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us all elements of x EXCEPT for the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.
  CorrectAnswer: x[c(-2, -10)]
  AnswerTests: omnitest(correctExpr='x[c(-2, -10)]')
  Hint: Give x[c(-2, -10)] a try.

- Class: cmd_question
  Output: A shorthand way of specifying multiple negative numbers is to put the negative sign out in front of the vector of positive numbers. Type x[-c(2, 10)] to get the exact same result.
  CorrectAnswer: x[-c(2, 10)]
  AnswerTests: omnitest(correctExpr='x[-c(2, 10)]')
  Hint: Use x[-c(2, 10)] to simply things a bit. This could be a time saver if specifying many negative indexes.

- Class: text
  Output: Now you know several methods of subsetting data from vectors. Different approaches are best in different scenarios and when in doubt, try it out!

- Class: figure
  Output: This lesson is complete! But before you leave, you'll need to generate a code with your UCL student number to show you've completed it, and post it on Moodle. 
  Figure: finalcode.R
  FigureType: new

- Class: figure
  Output: Final step: generate your completion code from your UCL student number (on your card)
  Figure: finalcode.R
  FigureType: new

- Class: cmd_question
  Output: Type completioncode(YOUR_7_DIGIT_NUMBER). Example: completioncode(1007893).
  CorrectAnswer: completioncode(1234567)
  AnswerTests: expr_uses_func("completioncode")
  Hint: Replace 1234567 with your own 7-digit student number, e.g., completioncode(1XXXXXX).
  
- Class: text
  Output: ✅ Copy your code and paste it in Moodle under “Flipped Coding 1 — Completion Code”.

- Class: text
  Output: 📸 If Moodle asks for a screenshot, include the console line showing completioncode(YOURNUMBER) and the printed code.
  
- Class: text
  Output: 💾 Saving & exiting: type bye() to exit and save your progress. To return to the main menu (without exiting R), type main(). You can experiment with play() and resume with nxt(). Your code remains valid once generated.




